C++高级
一、函数模版和类模板（泛型编程）

1.函数模版与普通函数在一起时：
	函数模板可以像普通函数一样被重载
	C++编译器优先考虑普通函数，普通函数可以进行隐式的类型转换
	如果函数模板可以产生一个更好的匹配，那么选择模板
	可以通过空模板实参列表的语法限定编译器只通过模板匹配
	函数模版的应用比较局限，不能进行隐式的类型转换

2.函数模版的本质：
	编译器并不是把函数模版处理成能够处理任意类的函数；
	编译器从函数模版通过具体类产生不同的函数；
	编译器会对函数模版进行两次编译；
	在声明的地方对模版代码本身进行编译；在调用的地方对参数替换后的代码进行编译。

3.重载<<和>>只能用友元函数，其他运算符重载都要写成成员函数，不要滥用友元函数。

4.
所有的类模板函数写在类的内部，没有什么大问题。
所有的类模板写在类的外部，但在一个.cpp文件中。
友元函数：
1）需要在类前增加类的前置声明 函数的前置声明
	template<typename T>
	class Complex;  
	template<typename T>
	Complex<T> mySub(Complex<T> &c1, Complex<T> &c2);（友元函数但是并非重载运算符函数，则要增加函数的前置声明）

2）类的内部声明：
	friend ostream& operator<< <T> (ostream &out, Complex<T> &c3) ;
	friend Complex<T> mySub <T> (Complex<T> &c1, Complex<T> &c2);

3）友元函数实现：//滥用友元函数
①　template<typename T>
	Complex<T> mySub(Complex<T> &c1, Complex<T> &c2)
	{
				Complex<T> tmp(c1.a - c2.a, c1.b-c2.b);
				return tmp;
	}
②　template <typename T>
	ostream & operator<<(ostream &out, Complex<T> &c3)
	{
				out <<  c3.a << " + " << c3.b <<  "i" << endl;
				return out;
	}
4)友元函数调用
	Complex<int> c4 = mySub<int>(c1, c2);
	cout<<c4;
所有的类模板写在类的外部，在不同的.h和.cpp文件中
滥用的友元函数在此时报错。

5.类模板中的static关键字：
从类模板实例化的每个模板类有自己的类模板数据成员，该模板类的所有对象共享一个static数据成员
  和非模板类的static数据成员一样，模板类的static数据成员也应该在文件范围定义和初始化
	Template <typename T>
	T 类名<T>：：静态数据成员 = 0;// 在类外对静态数据成员进行初始化。
每个模板类有自己的类模板的static数据成员副本

二、C++的类型转换
static_cast		    静态类型转换。如int转换成char
reinterpreter_cast 	重新解释类型 
dynamic_cast		    动态类型转换。如子类和父类之间的多态类型转换。
const_cast		    字面上理解就是去const属性。

4种类型转换的格式：
	TYPE B = static_cast<TYPE> (a)  

三、异常处理机制
1.异常机制的捕捉方式基于类型匹配。
2.栈解旋（unwinding）：异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象，都会被自动析构。

四、STL（标准模板库）
1.STL的重要特点：数据结构与算法的分离。

		序列式容器（Sequence containers）：vector、deque、list 
			每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。
2.容器
		关联式容器（Associated containers）：set、multiset、map、multimap
			元素位置取决于特定的排序准则，和插入顺序无关 
  数据结构							描述											      实现头文件
向量(vector)				连续存储的元素													<vector>

链表(list)					由节点组成的双向链表，每个结点包含着一个元素					<list>

双队列(deque)				连续存储的指向不同元素的指针所组成的数组						<deque>

集合(set)					由节点组成的红黑树，每个节点都包含着一个元素，
							节点之间以某种作用于元素对的谓词排列，							<set>
							没有两个不同的元素能够拥有相同的次序							

多重集合(multiset)			允许存在两个次序相等的元素的集合								<set>

栈(stack)					后进先出的值的排列												<stack>

队列(queue)					先进先出的执的排列												<queue>

优先队列(priority_queue)	元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列	<queue>

映射(map)					由{键，值}对组成的集合，以某种作用于键对上的谓词排列			<map>

多重映射(multimap)			允许键对有相等的次序的映射										<map>

