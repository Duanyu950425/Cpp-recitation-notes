面试知识总结
======
1.printf函数运算顺序
--------------
&emsp;printf函数的执行顺序是由右到左的。右边的先压入栈，左边的再入栈。

	void main()
	{
		int a=5, b=2;
		printf("%d, %d\n", b=a+1, a=a+1);
	}

结果为7,6

2.(int&)a和(int)a的区别
-------------------

	int main02()
	{
		float a = 1.0f;
		cout << (int)a << endl;
		cout << &a << endl;
		cout << (int&)a << endl;
		cout <<boolalpha << (int)a == (int&)a) << endl;
		cout << endl;
		cout << sizeof(int) << endl;
		cout << endl;
		float b = 0.0f;
		cout << (int)b << endl;
		cout << &b << endl;
		cout << (int&)b << endl;
		cout <<boolalpha << (int)b == (int&)b) << endl;

**(int&)a：**将a的引用强制转换为整型，意思是a所在的内存，本来定义的时候为float类型，并初始化为1.0f，但现在我要按照int类型解释这段内存（也就是说a所在的内存地址中的数据本来是按float型存储表示的，你非要按int型来解释不可）。

float类型数据占4个内存，即32位。

&emsp;符号位：转化为二进制后，第31位。0代表正数，1代表负数。

&emsp;阶码：30~23位，共8位，转化成规格化的二进制之后与127之和。

&emsp;尾数：22~0位。

例：13.625在内存中的存储。

13=(1101)2    0.625=(0.101)2    13.625=(1101.101)2

&emsp;将小数点向左移至小数点前只有一个1，即左移3位，1.101101。

阶码：3+127=130=(10000010)2

符号位：0

尾数：（小数点后的数再补零）10110100000000000000000

![](https://i.imgur.com/ZjgyBJ4.png)

则对于此问题中的代码来说：

a=1.0f，

符号位：0

阶码：0+127=127=(01111111)2

尾数：16个0

![](https://i.imgur.com/vSTC1Ki.png)

**(int&)a 相当于 *(int*)(&a)   *((int*)&a)**

	cout<<boolalpha<<((int)a==(int&)a)<<endl;  //输出false

而对于b来说，b=0.0f，(int)b=0，&b=(0012FF78)16，(int&)b=0，

因此，`cout<<boolalpha<<((int)b==(int&)b)<<endl;  //输出true。`

3.using namespace
-----------------
这是C++才会有的特性。

&emsp;假如你使用一个程序库，他里面有个变量abc，但是你自己也不小心定义了一个叫abc的变量，这样就会引起重定义错误，所以为了避免这种现象，C++引入了命名空间（namespace）的概念，编写程序库的时候最好吧所有东西的东西放在一个namespace中。例如

	namespace MY
	{
		int abc;
		char abc;
	}

&emsp;这样，你再外界就要通过 `MY：：abc `来访问MY里面的abc，而如果你自己在外面定义了一个叫abc的变量，不会引起重定义的错误，直接调用abc会调用你自己定义的abc，而只有用 `MY：：abc `才会真正调用出MY里面的abc...

4.using namespace std
---------------------

&emsp;所谓namespace，是指标识符的各种可见范围。C++标准程序库中所有标识符都被定义于一个名为std的namespace中。

iostream和iostream.h的区别

&emsp;前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件夹，打开文件夹会发现，里面的代码是不一样的。后缀为.h的头文件C++标准已经明确提出不支持了，早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，C++为了来和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。因此，当使用 `<iostream.h>` 时，相当于在c中调用库函数，使用的是全局命名空间，也就是早期的C++实现；当使用`<iostream>` 的时候，该头文件没有定义全局命名空间，必须使用 `namespace std；`这样才能正确使用cout。

&emsp;C++标注程序库中的所有标识符都被定义于一个名为std的namespace中。由于namespace的概念，使用C++标准程序库的任何标识符时，可以有三种选择：

#### （1）直接指定标识符 ####

例如 `std::iostream` 而不是iostream。完整语句如下：	

	std::cout<<std::hex<<3.4<<std::endl;

#### （2）使用using关键字 ####

	using std::cout; using std::endl; using std::cin

以上程序可以写成如下代码：

	using std::cout<<using std::hex<<3.4<<using std::endl;

#### （3）使用using namespace std ####

例如：

	#include<iostream>   
	#include<sstream>    
	#include<string>   
	using namespace std;

&emsp;这样命名空间std内定义的所有标识符都有效。就好像他们被声明为全局变量一样。那么以上语句可以如下写：

	cout<<hex<<3.4<<endl；

&emsp;因为标准库非常庞大，所以程序员在选择的类的名称或函数名时就有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都放在名字空间std中。但这又会带来一个新问题。无数原有的C++代码都依赖于使用了多年的为标准库中的功能，他们都是在全局空间下的。所以就有了<iostream>和<iostram.h>等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。明明空间std封装的是标准程序库的名称，标准程序库为了和一千的头文件区别，一般不加“.h”。

5.不同平台下类型占用内存
-----------------------

<table>
    <tr>
        <td colspan="2">32位平台</td> 
        <td colspan="2">64位平台</td>
   </tr>
    <tr>
        <td>char</td>
        <td>1个字节8位</td   
		<td>char</td   
		<td>1个字节8位</td    
    </tr>
    <tr>
        <td>short</td   
		<td>2个字节16位</td  
		<td>short</td  
		<td>2个字节16位</td   
    </tr>
	<tr>
        <td>int</td   
		<td>4个字节32位</td  
		<td>int</td  
		<td>4个字节32位</td   
    </tr>
	<tr>
        <td>long</td   
		<td bgcolor=#FF3E96>4个字节</td  
		<td>long</td  
		<td bgcolor=#FF3E96>8个字节</td   
    </tr>
	<tr>
        <td>long long</td   
		<td>8个字节</td  
		<td>long</td  
		<td>8个字节</td   
    </tr>
	<tr>
        <td>指针</td   
		<td bgcolor=#FF3E96>4个字节</td  
		<td>指针</td  
		<td bgcolor=#FF3E96>8个字节</td   
    </tr>
</table>

C标准规定：长整型（long）至少应该和整型（int）一样长，而整型（int）至少应该和短整型（short int）一样长。（具体long int short是多大存储空间有不同的编译器决定）。

short int至少2个字节。

long int至少4个字节。

6.强制类型转换（关于指针）
------------------------
	
	int main03()
	{
		unsigned int a = 0xFFFFFFF7;
		unsigned char i = (unsigned char) a;
		char *b = (char *) &a;
			
		printf( "%08x, %08x", i, *b);
		return 0;
	}

**解析：**在X86系列的机器中，数据的存储是“小端存储”，小端存储的意思就是，对于一个跨多个字节的数据，其地位存放在低地址单元，其高位存放在高地址单元。比如一个int类型的数据ox12345678，加入存放在0x00000000中存放的是低位的0x78，而ox00000003中存放的是高位的0x12，以此类推。

	unsigned char i = (unsigned char) a;
	//将unsigned int a强制转换为unsigned char a，此时发生截断，并将其赋值给unsigned char i，unsigned int是4个字节，unsigned char是1个字节的，发生截断，unsigned char i=0xF7.

	char *b = (char *) &a;
	//&a可以认为是个之相关unsigned int类型数据的指针。(char *)&a则把&a强制转换成char*的指针，并且在这个时候发生了截断。截断后，指针b只指向0xF7这个数据。
	
	//又由于指针b是char*型的，属于有符号数，所以有符号数0xF7。而printf中的格式控制为%08x是以8位16进制的格式输出int类型的数据。所以0xF7被隐式类型转换为4位的有符号int，高位填充符号位1，所以为0xfffffff7.


7.printf格式 
-----------

### 1）类型 ###

|格式字符	|意义|
|:--------:|:---:|
|d|	以十进制形式输出带符号整数（整数不输出符号）|
|o|	以八进制形式输出无符号整数（不输出前缀0）|
|x,X|	以十六进制形式输出无符号整数（不输出前缀0x）|
|u|	以十进制形式输出无符号整数|
|f|	以小数形式输出单、双精度实数|
|e,E|	以指数形式输出单、双精度实数|
|g,G|	以%f或%e中较短的输出宽度输出单、双精度实数|
|c|	输出单个字符|
|s|	输出字符串|

### 2）标志 ###

|标志	|意义|
|:----:|:---:|
|-|	结果左对齐，右边填空格|
|+|	输出符号（正号或符号）|
|空格|	输出值为正时冠以空格，为负时冠以符号|
|#|	对c、s、d、u类无影响；对o类，在输出时加前缀o；对x类，在输出时加前缀0x；对e、g、f类当结果有小数时才给出小数点|

### 3）输出最小宽度 ###

&emsp;用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度，则补以空格或0.

### 4）精度 ###

&emsp;精度格式符以“.”开头，后跟十进制整数。本项的意义是：如果输出数字，则表示小数的位数；如果输出的是字符，则表示输出字符的个数；若实际位数大于所定义的镜度数则截去超过的部分。

### 5）长度 ###

&emsp;长度格式符为h、l两种，h表示按短整型量输出，l表示按长整型量输出。

	int main(void)
	{
		int a = 15;
		long float b = 123.1234567;
		double c = 12345678.1234567;
		char d = 'p';

		printf( "a = %d \n", a);
		printf( "a(%%d) = %d, a(%%5d) = %5d, a(%%o) = %o, a(%%x) = %x\n\n", a, a, a, a);
		//”%5d”要求输出宽度为5，而a值为15只有两位数，前面补3个空格。
		//”%o”以八进制形式输出无符号整数（不输出前缀0）

		printf( "b = %f \n", b);
		printf( "b(%%f) = %f, b(%%lf) = %lf, b(%%5.41f) = %5.41f, b(%%e) = %e\n\n", b, b, b, b);
		//”%f”和”%lf”格式相同，以小数形式输出单、双精度实数
		//”%5.4lf”指定输出宽度为5，精度为4，由于实际长度超过5，应该按实际长度位数输出，小数位数超过4位部分被截去

		printf( "c = %f \n", b);
		printf( "c(%%lf) = %lf, c(%%f) = %f, c(%%8.41f) = %8.41f\n\n", c, c, c);
		//输出双精度实数，”%8.4lf”由于指定精度为4位故截去了超过4位的部分。

		printf( "d = %c \n", b);
		printf( "d(%%c) = %c, d(%%8c) = %8c\n\n", d, d);
		//输出字符量d，其中”%8c”指定宽度为8故在输出字符p之前补加7个空格。

		return 0;
	}

![](https://i.imgur.com/uDNcEOA.png)


8.C\C++获取变量类型
-------------

	unsigned int _a = 5;
	cout << typeid(_a).name() << endl; 

![](https://i.imgur.com/8ECwVo7.png)

9.C语言隐式类型转换 
------------

### 1）算数转换 ###

&emsp;进行算术运算（加、减、乘、除、取余以及符号运算）时，不同类型数必须转换成同一类型的数据才能运算，算数转换原则为：

![](https://i.imgur.com/7k9eURt.png)

整形提升：对于所有比int小的类型，包括char，signed char，unsigned char，short，unsigned short，首先会提升为int类型。

&emsp;在进行运算时，以表达式中最长类型为主，将其他类型位据均转换成该类型，如：

（1）若运算数中有double型或float型，则其他类型数据均转换成double类型进行运算。

（2）若运算数中最长的类型为long型，则其他类型数均转换成long型数。

（3）若运算数中最长类型为int型，则char型也转换后才能int型进行运算。算数转换是在运算过程中自动完成的。

特别注意有符号和无符号之间的转换：

&emsp;&emsp;包含long与unsigned int，32位及其上都是4字节，所以均转换成unsigned long；

&emsp;&emsp;包含signed与unsigned int，signed会转换为unsigned。如果int恰好为负数，其结果为对unsigned取值个数求模的结果。**在进行自动类型转换的时候，如果原来的是数是无符号数，那么在扩展的时候，高位填充的是0；如果是有符号数，那么高位填充的是符号位。**

### 2）赋值转换 ###

&emsp;进行赋值操作时，赋值运算符右边的数据类型必须转换成赋值号左边的类型，若右边的数据类型的长度大于左边，则要进行截断或舍入操作。

	char ch;
	int i, result;
	float f;
	double d;
	result = ch/i + (f*d-i);


- 首先计算ch/i，ch--->int型，ch/i---->int型

- 接着计算f*d-i，由于最长型为double型，故f--->double型，i--->double型，f*d-i---->double型

- (ch/i)和(f*d-i)进行加运算，由于f*d-i为double型，故ch/i--->double型，ch/i+(f*d-i)--->double型

- 由于result为int型，故ch/i+(f*d-i)---->double--->int，即进行截断与舍入，最后取整为整型。

### 3）输出转换 ###

&emsp;在程序中将数据用printf函数以指定格式输出时，当要输出的数据类型与输出格式不符时，便自动进行类型转换，如一个long型数据用整形格式(%d)输出时，则相当于将long型转换成整型(int)数据输出；一个字符(char)型数据用整形格式输出时，相当于将char型转换成int型输出。

&emsp;注意：较长型数据转换成短型数据输出时，其值不能超出短型数据允许的范围，否则转换时将出错。

10.C语言运算符优先级 
-------------

	int main06()
	{
		unsigned char a = 0xA5; //(1010 0101)2
		unsigned char b = ~a >> 4+1;
		//”~”的优先级高于”>>”和”+”。先对a取反，再向右移（4+1）位。在进行~a操作时，会先将a进行整形提升，a是无符号的，所以提升为4位int型，char为1位，左边补充24个0。取反操作，将(0...0 1010 01001)2取反，变为(1...1 0101 1010)2再向右移5位，按照无符号数读取，(1111 1010)2=250

		printf( "b = %d\n", b);
		return 0;
	}


<table>
    <tr>
        <td>优先级</td> 
        <td>运算符</td>
		<td>名称或含义</td>
		<td>使用形式</td>
		<td>结合方向</td>
		<td>说明</td>
   </tr>
    <tr>
		<td rowspan="4">1</td>
		<td>[]</td   
		<td>数组下标</td   
		<td>数组名[常量表达式]</td   
		<td rowspan="4">左到右</td  
		<td rowspan="4"></td   
    </tr>
    <tr>
        <td>()</td   
		<td>圆括号</td   
		<td>（表达式）/函数名（形参表）</td   
    </tr>
	<tr>
        <td>.</td   
		<td>成员选择（对象）</td   
		<td>对象.成员名</td
    </tr>
	<tr>
         <td>-></td   
		<td>成员选择（指针）</td   
		<td>对象指针->成员名</td
    </tr>
	<tr>
		<td rowspan="9">2</td>
		<td>-</td   
		<td>负号运算符</td   
		<td>-表达式</td   
		<td rowspan="9">右到左</td  
		<td rowspan="7">单目运算符</td   
    </tr>
	<tr>
        <td>~</td   
		<td>按位取反运算符</td   
		<td>~表达式</td
    </tr>
	<tr>
        <td>++</td   
		<td>自增运算符</td   
		<td>++变量名/变量名++</td
    </tr>	
	<tr>
        <td>--</td   
		<td>自减运算符</td   
		<td>--变量名/变量名--</td
    </tr>
	<tr>
        <td>*</td   
		<td>取值运算符</td   
		<td>*指针变量</td
    </tr>
	<tr>
        <td>&</td   
		<td>取地址运算符</td   
		<td>&变量名</td
    </tr>
	<tr>
        <td>!</td   
		<td>逻辑非运算符</td   
		<td>！表达式</td
    </tr>
	<tr>
        <td>（类型）</td   
		<td>强制类型转换</td   
		<td>（数据类型）表大会</td
		<td></td
    </tr>
	<tr>
        <td>sizeof</td   
		<td>长度运算符</td   
		<td>sizeof（表达式）</td
		<td></td
    </tr>
	<tr>
		<td rowspan="3">3</td>
		<td>/</td   
		<td>除</td   
		<td>表达式/表达式</td   
		<td rowspan="3">左到右</td  
		<td rowspan="3">双目运算符</td   
    </tr>
	<tr>
        <td>*</td   
		<td>乘</td   
		<td>表达式*表达式</td
    </tr>
	<tr>
        <td>%</td   
		<td>取余</td   
		<td>整型表达式%整形表达式</td
    </tr>
	<tr>
		<td rowspan="2">4</td>
		<td>+</td   
		<td>加</td   
		<td>表达式+表达式</td   
		<td rowspan="2">左到右</td  
		<td rowspan="2">双目运算符</td   
    </tr>
	<tr>
        <td>-</td   
		<td>减</td   
		<td>表达式-表达式</td
    </tr>
	<tr>
		<td rowspan="2">5</td>
		<td><<</td   
		<td>左移</td   
		<td>变量<<表达式</td   
		<td rowspan="2">左到右</td  
		<td rowspan="2">双目运算符</td   
    </tr>
	<tr>
        <td>>></td   
		<td>右移</td   
		<td>变量>>表达式</td
    </tr>
	<tr>
		<td rowspan="4">6</td>
		<td>></td   
		<td>大于</td   
		<td>表达式>表达式</td   
		<td rowspan="4">左到右</td  
		<td rowspan="4">双目运算符</td   
    </tr>
	<tr>
        <td>>>=</td   
		<td>大于等于</td   
		<td>表达式>=表达式</td
    </tr>
	<tr>
        <td>><</td   
		<td>小于</td   
		<td>表达式<表达式</td
    </tr>
	<tr>
        <td><=<</td   
		<td>小于等于</td   
		<td>表达式<=表达式</td
    </tr>
	<tr>
		<td rowspan="2">7</td>
		<td>==</td   
		<td>等于</td   
		<td>表达式==表达式</td   
		<td rowspan="2">左到右</td  
		<td rowspan="2">双目运算符</td   
    </tr>
	<tr>
        <td>!=<</td   
		<td>不等于</td   
		<td>表达式!=表达式</td
    </tr>
	<tr>
		<td>8</td>
        <td>&<</td   
		<td>按位与</td   
		<td>表达式&表达式</td
		<td>左到右</td  
		<td>双目运算符</td
    </tr>
	<tr>
		<td>9</td>
        <td>^<</td   
		<td>按位异或</td   
		<td>表达式^表达式</td
		<td>左到右</td  
		<td>双目运算符</td
    </tr>
	<tr>
		<td>10</td>
        <td>|<</td   
		<td>按位或</td   
		<td>表达式|表达式</td
		<td>左到右</td  
		<td>双目运算符</td
    </tr>
	<tr>
		<td>11</td>
        <td>&&<</td   
		<td>逻辑与</td   
		<td>表达式&&表达式</td
		<td>左到右</td  
		<td>双目运算符</td
    </tr>
	<tr>
		<td>12</td>
        <td>||<</td   
		<td>逻辑或</td   
		<td>表达式||表达式</td
		<td>左到右</td  
		<td>双目运算符</td
    </tr>
	<tr>
		<td>13</td>
        <td>?:<</td   
		<td>条件运算符</td   
		<td>表达式1？表达式2：表达式3</td
		<td>右到左</td  
		<td>三目运算符</td
    </tr>
	<tr>
		<td rowspan="11">14</td>
        <td>=<</td   
		<td>赋值运算符</td   
		<td>变量=表达式</td
		<td rowspan="11">右到左</td  
		<td rowspan="11"></td
    </tr>
	<tr>
        <td>/=<</td   
		<td>除后赋值</td   
		<td>变量/=表达式</td
    </tr>
	<tr>
        <td>*=<</td   
		<td>乘后赋值</td   
		<td>变量*=表达式</td
    </tr>
	<tr>
        <td>%=<</td   
		<td>取模后赋值</td   
		<td>变量%=表达式</td
    </tr>
	<tr>
        <td>+=<</td   
		<td>加后赋值</td   
		<td>变量+=表达式</td
    </tr>
	<tr>
        <td>-=<</td   
		<td>减后赋值</td   
		<td>变量-=表达式</td
    </tr>
	<tr>
        <td><<=<</td   
		<td>左移后赋值</td   
		<td>变量<<=表达式</td
    </tr>
	<tr>
        <td>>>=<</td   
		<td>右移后赋值</td   
		<td>变量>>=表达式</td
    </tr>
	<tr>
        <td>&=<</td   
		<td>按位与后赋值</td   
		<td>变量&=表达式</td
    </tr>
	<tr>
        <td>^=<</td   
		<td>按位异或后赋值</td   
		<td>变量^=表达式</td
    </tr>
	<tr>
        <td>|=<</td   
		<td>按位或后赋值</td   
		<td>变量|=表达式</td
    </tr>
	<tr>
		<td>15</td>
        <td>,<</td   
		<td>逗号运算符</td   
		<td>表达式，表达式，……</td
		<td>左到右</td  
		<td></td
    </tr>
</table>

11.用位运算符实现加减法
-------------

### 1）按位与运算符（&）： ###

（1）清零：原来的数中为1的位，新数中相应位为0。然后使二者进行&运算，即可达到清零目的。

	int main()
	{
		int a = 43;
		int b = 148;
		printf( "%d", a&b);
		return 0;
	}

输出0。

（2）取一个数中某些指定位：若有一个整数a(2byte)，想要取其中的低字节，只需要将a与8个1按位与即可。

（3）保留指定位：与一个数进行“按位与”运算，次数在该位上取1。

&emsp;有一数84,01010100，想把其中从左边算起的第3,4,5,7,8位保留下来：

	int main()
	{
		int a = 84;
		int b = 59;
		printf( "%d\n", a&b);
		return 0;
	}

输出16。

2）按位或运算（|）：将一个位串信息的某几位置成1

3）按位异或运算（^）：

&emsp;&emsp;&emsp;0^任意数=任意数

&emsp;&emsp;&emsp;1^任意数=~任意数

&emsp;&emsp;&emsp;任意数^任意数=置0

a=3，b=4,想将a和b的值互换：

	int main()
	{
		int a = 3;
		int b = 4;
		a = a^b;
		b = b^a;
		a = a^b;
		printf( "%d\n", a);
		return 0;
	}

输出4。

4）按位取反运算符（~）：当两个长度不同的数据进行位运算时（例如long型数据与int型数据），将两个运算分量的右端对齐进行为运算。如果短的数为整数，高位用0补满；**如果短的数为负数，高位用1补满。如果短得为无符号整数，则高位总是用0补满。**

5）左移运算符（<<）

左移1位====>>该数乘以2；左移2位====>>该数乘以2*2=4。

此结论只适用于该数左移时被溢出舍弃的高位不包含1的情况。

6）右移运算符（>>）

&emsp;右移运算符是用来讲一个数的各二进制位右移若干位，移动的位数由右操作数指定（右操作数必须是非负值），移到右端的低位被舍弃。对于无符号数，高位补0；对于有符号数，某些机器将左边空出的部分用符号位填补（“算数移位”），另一些机器则对左边空出的部分用0填补（“逻辑移位”）。

右移1位====>>该数除以2；右移2位====>>该数除以2*2=4。

7）判断一个数是否是 ![](https://i.imgur.com/ZxMXSPL.png)  

	！（X&（X-1））

8）

	int Add(int a, int b)
	{
		if (b == 0)
			return a;
		int sum, carray;
		sum = a^b;
		carray = (a&b) << 1;
		return Add(sum, carry);
	}
	int main()
	{
		cout << Add(9, 10) << endl;
		return 0;
	}

12.ifndef/define/endif作用和用法

例子：假设工程中有4个文件，分别是a.cpp，b.h，c.h，d.h。

a.cpp的头部是：

		#include“b.h”
        #include“c.h”

b.h和c.h的头部都是：

		#include“d.h”

而d.h中有class D的定义。

&emsp;这样一来，编译器编译a.cpp的时候，先根据#include“b.h”去编译b.h这个问题，在根据b.h里面的#include“d.h”去编译d.h这个文件，这样就把d.h里面的class D编译了；

&emsp;然后在根据a.cpp的第二句#include“c.h”去编译c.h，最终还是会找到的d.h里面的class D，但是class D之前已经编译过了，所以就会报重定义错误。

&emsp;加上ifndef/define/endif，就可以防止这种重定义错误。除了头文件被防止重复应用，还可以防止重复定义（变量，宏或者结构）。

13.Switch没有break的问题
-------------------

	int main()
	{
		int n = 'c';
		switch(n++)
		{
		default: printf("error"); break;
		case 'a': case 'A': case 'b': case 'B': printf("ab"); break;
		case 'c': case 'C': printf("c");
		case 'd': case 'D': printf("d");
		}
	} 

如果case语句后不加break，就依次执行下去。

14.结构体字节自动对齐
------------

### （1）基本概念 ###

字节对齐：计算机存储系统中以Byte为单位存储数据，不同数据类型所占的空间不同，如：整型（int）数据占4个字节，字符型（char）数据占1个字节，短整型（short）数据占两个字节……。计算机为了快速的读写数据，默认情况下将数据存放在某个地址的起始位置，如：整型数据（int）默认存储在地址能被4整除的起始位置，字符型数据（char）可以存放在任何地址位置（被1整除），短整型（short）数据存储在地址能被2整除的起始位置。这就是默认字节对齐方式

### （2）举例说明 ###
  
	struct student
	{
		char name[5];
		int num;
		short score;
	};

&emsp;0 &emsp;1&emsp;&emsp;2&emsp;&emsp;3

|char|char|char|char|

  &emsp;4 &emsp;5 &emsp;&emsp;6 &emsp;&emsp;7

|char|------|------|------|

&emsp;8 &emsp;9 &emsp;10 &emsp; 11

|-----------int------------|

 &emsp;12&emsp;13 &emsp;14 &emsp;15

|----short---|------|------|

&emsp;本来只用了11bytes=5+4+2的空间，但是由于int型摩恩4字节对齐，存放在地址能被4整除的起始位置，即：如果name[5]从0开始存放，它占5bytes，而num则从第8（偏移量）个字节开始存放。所以sizeof（student）=16。这样便于计算机快速读写数据，是一种以空间换取时间的方式。

i）如果我们将结构体中变量的顺序改变为：

	struct student
	{
		int num;
		char name[5];
		short score;
	};

&emsp;0 &emsp;1&emsp;&emsp;2&emsp;&emsp;3

|-----------int------------|

  &emsp;4 &emsp;5 &emsp;&emsp;6 &emsp;&emsp;7

|char|char|char|char|

&emsp;8 &emsp;9 &emsp;10 &emsp; 11

|char|------|----short---|

&emsp;num从0开始存放，而name从第4（偏移量）个字节开始存放，连续5个字节，score从第10（偏移量）开始存放，故sizeof（student）=12。

ii）如果我们将结构体中变量再次改变为：

	struct student
	{
		int num;
		short score;
		char name[5];
	};

&emsp;0 &emsp;1&emsp;&emsp;2&emsp;&emsp;3

|-----------int------------|

  &emsp;4 &emsp;5 &emsp;&emsp;6 &emsp;&emsp;7

|----short---|char|char|

&emsp;8 &emsp;9 &emsp;10 &emsp; 11

|char|char|char|------|


sizeof（student）=12。

### （3）#pragma pack()命令 ###

&emsp;为了节省空间，我们可以在编码时通过#pragma pack（）命令指定程序的对齐方式，括号中是对齐的字节数，若该命令括号中的内容为空，则为默认对齐方式。例如，对于上面第一个结构体，如果通过该命令手动设置对齐字数如下：

	//字节对齐
	#pragma pack(2)//设置字节对齐
	struct student
	{
		char name[5];//本身1字节对齐，比2字节对齐小，按1字节对齐
		int num;     //本身4字节对齐，比2字节对齐大，按2字节对齐
		short score;  //本身2字节对齐，仍然按2字节对齐
	}；

&emsp;0    &emsp;1  

|char|char|

  &emsp;2    &emsp;3

|char|char|

  &emsp;4    &emsp;5

|char|------|

  &emsp;6   &emsp; 7

|-----int-----|

  &emsp;8    &emsp;9

|-----int-----|

  &emsp;10   &emsp;11

|---short---|

&emsp;则，num从第6（偏移量）个字节开始存放，score从第10（偏移量）个字节开始存放，故sizeof（student）=12，score后还有1个字节空闲。

&emsp;这样改变默认的字节对齐方式可以更充分利用存储空间，但是这回降低计算机读写数据的速度，**是一种以时间换区空间的方式。**

### （4）例子 ###

	class A1
	{
	public:
		int a;
		static int b;

		A1();
		~A1();
	};
	class A2
	{
	public:
		int a;
		char c;
	
		A2();
		~A2();
	};
	class A3
	{
	public:
		float a;
		char c;
		
		A3();
		~A3();
	};
	class A4
	{
	public:
		float a;
		int b;
		char c;
			
		A4();
		~A4();
	};
	class A5
	{
	public:
		doubl d;
		float a;
		int b;
		char c;

		A5();
		~A5();
	};
	int main()
	{
		cout << "A1 size = " << sizeof(A1) << endl;
		cout << "A2 size = " << sizeof(A2) << endl;
		cout << "A3 size = " << sizeof(A3) << endl;
		cout << "A4 size = " << sizeof(A4) << endl;
		cout << "A5 size = " << sizeof(A5) << endl;
		return 0;
	}

![](https://i.imgur.com/qmv8G98.png)

15.为什么C语言要求字节对齐，结构体也要求字节对齐
--------------------------

&emsp;这是为了存取。

16.C\C++编译器内存分配
---------------
比较

	char *toStr()
	{
		char *s = "abcdefgijkl";//字符串常量，位于文字常量区
								//程序整体结束的时候才会释放
		return s;
	}
	int main()
	{
		cout << toStr() <<endl;
		return 0;
	}

和

	char *toStr()
	{
		char s[] = "abcdefgijkl";//数组字符串
								//是以字符元素的格式存放在字符数组中
		return s;
	}
	int main()
	{
		cout << toStr() <<endl;
		return 0;
	}

&emsp;前一段代码打印出来是字符串，而后一段代码打印出来是乱码。字符串是被当做字符数组来处理的。所以字符数组名就相当于指向首地址的指针。那么

（1）char *s=”abcdefghijkl”;

（2）char s[]=”abcdefghijkl”;

&emsp;这两种表达式似乎是一样的，而出现乱码的原因就是没有对内存分配了解好。

解释：

第一种表达式，指针s是局部变量，被分配在栈空间，他的作用域是函数toStr内。其指向的内容”abcdefghijkl”是常量，被分配在程序的常量区。它将其指向的地址返回（整个程序结束），返回之后s即被销毁，庆幸s指向的地址呗返回了回来。最终打印正确。

第二种表达式，s是以数组，分配到栈空间，”abcdefghijkl”作为数组各个元素被放到数组中，一旦函数退出，栈中这块内存就被释放，虽然返回一个地址，可是已经失去意义了。
                 


- 内存分配问题

 变量的类型和它的存储类别是两个概念
 
数据类型和内存管理没有直接的关系

### 一、一个由C\C++变异的程序占用的内存分为以下几个部分： ###

（1）栈区（stack）——由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

（2）堆区（heap）——一般由程序员分配释放，若程序员不释放，程序结束时可能有OS回收。注意它与数据结构中的堆是两回事，分配方式导师类似于链表。

（3）全局区（静态区）（static）——全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量存储在相邻的另一块区域，程序结束后由系统释放。

（4）文字常量区——常量字符串就是放在这里的。程序结束后由系统释放。

（5）程序代码区——存放函数体的二进制代码。

### 二、例子程序 ###

	int main()
	{
		int b;   //栈
		char s[] = "abc";  //栈
		char *p2;  //栈
		char *p3 = "123456";  //123456在常量区，p3在栈上
		static int c = 0;  //全局（静态）初始化区
		p2 = (char *) malloc (10); 
		p3 = (char *) malloc (20);//分配得来的10和20字节的区域就在堆区
		strcpy(p2, "123456");//123456放在常量区
							//编译器可能会将它与p3所指向的“123456”优化成一个地方

&emps;数值常量跟字符常量并不占用内存，在程序运行时他们作为操作数直接出现在cpu的寄存器中。常量的类型不同占用的寄存器位数不同。还有符号常量也不占用内存。#define PI3.1415926这里PI作为符号常量也是不占用内存的。

17.预处理与宏
--------

&emps;C++预处理是一些指令，指示编译器在实际编译之前所需要完成的预处理。所有的预处理器指令都是以#开头，只有空格字符可以出现在预处理指令之前。预处理指令不是C++语句，所以他们不会以分号结尾。

### 1.#define预处理： ####

&emps;define预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式为：

	#define macro-name replacement-text

例如：

	#include<iostream>
	usingn namespace std;
	
	#define PI 3.14159
	int main()
	{
		cout << "Value of PI:" << endl;
		return 0;
	}

### 2.参数宏： ###

&emps;使用#define来定义一个带有参数的宏

	#include<iostream>
	usingn namespace std;
	
	#define MIN(a, b) (a < b ? a: b)
	int main()
	{
		int i, j;
		i = 100;
		j = 30;
		cout << "较小的值为:" << MIN(i, j) << endl;
		return 0;
	}

### 3.条件编译 ###

（1）条件预处理器的结构与if选择结构很像：

	#ifdef NULL
		#define NULL 0
	#endif

（2）只在调试时进行编译，调试开关可以使用一个宏来实现：

	#include<iostream>
	usingn namespace std;

	#define DEBUG

	#define MIN(a, b) ( (a) < (b) ? a : b )
	int main()
	{
		int i, j;
		i = 100;
		j = 30;
	#ifdef DEBUG
		cerr << "Trace: Inside main function" << endl;
	#endif  //已经预先定义了符号常量DEBUG，则在调试时，执行条件编译

	#if 0
		cout << MKSIR (HELLO C++) << endl;
	#endif  //这是在调试时不进行编译的代码

		cout << "The minimum is " << MIN(i, j) << endl;
	#ifdef DEBUG
		cerr << "Trace: Inside main function" << endl;
	#endif
	return 0;
	}
	
### （3）#和##运算符 ###

①#运算符会把replacement-text令牌转换为引号引起来的字符串。

	#include<iostream>
	usingn namespace std;

	#define MKSTR(x) #x
	int main()
	{
		cout << MKSIR (HELLO C++) << endl;
		return 0;
	}

![](https://i.imgur.com/BSkxu3Y.png)

C++预处理器把

	cout << MKSIR (HELLO C++) << endl;

转换成了

	cout << "HELLO C++" << endl;

②##运算符用于连接两个令牌

	#include<iostream>
	usingn namespace std;

	#define concat(a, b) a##b
	int main()
	{
		int xy = 100;
		cout << concat (x, y) << endl;
		return 0;
	}

将 `cout << concat (x, y) << endl;` 转换为 `cout << xy << endl;`，又因为xy=100，所以输出100。

18.Sizeof与strlen以及字符串相关
-----------------------

	int main()
	{
		char a[] = "abcde\0\0\0";
		char *b = "edcba\0\0\0";

		cout << "字符串a占用的内存空间是：" << sizeof(a) << endl;
		cout << "字符串a的长度是：" << strlen(a) << endl;
		cout << "a的内容是：" << a << endl;

		cout << "字符串b占用的内存空间是：" << sizeof(b) << endl;
		cout << "字符串b的长度是：" << strlen(b) << endl;
		cout << "b的内容是：" << b << endl;
		return 0;
	}

![](https://i.imgur.com/11qYrWo.png)

b是一个指针，所以占用的内存空间是4。

19.char []与char *a的区别
---------------------

	char a[]=”abcde\0\0\0”;    字符串数组
	char *b=”edcba\0\0\0”;     这是指向字符串常量的指针。

区别：char a[]=”abcde\0\0\0”;这时a是一个地址常量（数组首地址）。是一个常量。他就是该数组的内存首地址。它不可以被赋值，因为它本身就是一个右值。在内存中abcde\0\0\0共8个元素加上字符串自动添加的“\0”结束符号，共9个元素。

&emsp;而b为一个字符串指针，它是一个变量，而char *b=”edcba\0\0\0”; 中的右值是一个字符串常量，它存放在常量区占用的空间也是8+1=9byte。而b是一个指针变量存放在栈中。

20.数组相关
-------

	int main()
	{
		char a[3] = { 'a', 'b'， 'c'};
		char a[3] = { 'a', 'b'， 'c'};
		char c[] = "abc";

		cout << strlen(a) << endl;
		cout << strlen(b) << endl;
		cout << strlen(c) << endl;

		cout << a <<endl;
		cout << b <<endl;
		cout << c <<endl;
		return 0;
	}

![](https://i.imgur.com/xq1pBU1.png)

&emsp;对于char a[3]={‘a’,’b’,’c’};虽然数组a定义为3个元素但是调用strlen（a）时，a被看做是一个字符串处理，所以会**一直计算到\0出现位置**，所以cout<<strlen(a)<<endl的输出并不确定。

&emsp;对于char b[4]={‘a’,’b’,’c’}；在给b[0]b[1]b[2]赋值abc后，会给b[3]自动赋值为\0，所以cout<<strlen(b)<<endl;输出时3。

&emsp;注意把char类型的指针或者地址常量给cout输出时，cout都会把它当做一个字符串进行输出。

21.关于数组名 指针和地址
--------------

&emsp;指针是一种地址变量，通常也叫指针变量，统称指针，它是一个变量，是一个左值。而地址则是地址变量的值。地址是一个常量，是一个右值。

&emsp;用来存放数组的区域是一块在栈中静态分配的内存（非static），而数组名是这块内存的代表，它被定义为这块内存的首地址。这就说明了数组名是一个地址，而且还是一个不可修改的常量，完整地说，就是一个地址常量，数组名跟枚举常量相似，都属于符号常量，数组名这个符号，就代表了那块内存的首地址。（注意：不是数组名这个符号的值是那块内存的首地址，而是数组名这个符号本身就代表了首地址这个地址值，它就是这个地址）由于数组名是一种符号常量，因此它是一个右值，而指针，作为变量，却是一个左值，一个右值永远都不会是左值，数组名永远都不会是指针。

&emsp;数组名是一个地址，一个符号地址常量，不是一个变量，更不是一个作为变量的指针。

22.指针与引用
--------

###  ###1）指针和引用的差别

1）非空区别。在任何情况下都不能使用指向空值的引用。一个引用必须总是指向某些对象。因此如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时你应该把变量声明为指针，因为这样你可以赋空值给该变量。相反，如果变量肯定指向一个对象，例如你的设计不允许变量为空，这时你就可以把变量声明为引用。

2）合法性区别。在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。

3）可修改区别。指针可以被重新赋值以指向另一不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象的内容可以改变。

4）应用区别。指针的应用场景：一是考虑到存在不知想任何对象的可能（在这种情况下，能够设指针为空），而是需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么应该使用引用。

### （2）传递动态内存 ###


23.指针专题
-------

### 一、指针的概念 ###

&emsp;指针是一个特殊的变量，它里面存储的数值被解释称为内存里的一个地址。要搞清一格指针需要搞清指针的四方面的内容：**指针的类型，指针所指向的类型，指针的值（指针所指向的内存区），还有指针本身所占据的内存区。**

	int *ptr;
	char *ptr;
	int **ptr;
	int (*ptr)[3];
	int *(*ptr)[4];


### 二、指针的类型 ###

&emsp;从语法的角度看，只要把指针声明语句例的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的的类型。

	int *ptr;    //指针的类型是int *
	char *ptr;	//指针的类型是char *
	int **ptr;	 //指针的类型是int **
	int (*ptr)[3]; //指针的类型是int(*)[3]
	int *(*ptr)[4];//指针的类型是int*(*)[4]

### 三、指针所指向的类型 ###

&emsp;当通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存块例的内容当做什么来看待。

&emsp;从语法上看，你只需要把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。

	int *ptr;    //指针所指向的类型是int
	char *ptr;	//指针所指向的类型是char
	int **ptr;	 //指针所指向的类型是int *
	int (*ptr)[3]; //指针所指向的类型是int()[3]
	int *(*ptr)[4];//指针所指向的类型是int*()[4]

### 四、指针的值 ###

&emsp;指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里的内存地址全都是32位长。

&emsp;指针所指向的内存区就是从指针的值所代表的你那个内存地址开始，长度为sizeof（指针所指向的类型）的一片内存区。我们说一个指针指向了某块内存区域，就相当于说改制镇的值是这块内存区域的首地址。

&emsp;指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在上例中，指针所指向的类型已经有啦，但是由于指针还未初始化，所以它所指向的内存区时不存在的，或者说是毫无意义的。

### 五、指针本身所占据的内存区 ###

&emsp;指针本身所占内存用sizeof测一下即可。在32位系统下，指针本身占据了4个字节的长度。

### 六、指针的算术运算 ###

&emsp;指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如：

	char a[20];
	char *ptr = a;

	ptr++;

&emsp;在上例中，指针ptr的类型是char *，它指向的类型是char，它被初始化为指向整型变量a。ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了1。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了1个字节。由于char类型的长度是一个字节，所以，原来ptr是指向数组a的第0号单元开始的一个字节，此时指向了数组a中从第2号单元开始的一个字节。也就是新的ptr指向的地址将比原来的ptr所指向的地址向高（低）地址方向移动了n*sizeof（类型）。其中n是移动的个数。

### 七、运算符&和* ###

&emsp;这里&是取地址运算符，*是间接运算符。&a的运算结果是一个指针，指针的类型是a的类型加个*，指针所指向的类型是a的类型，指针所指向的地址，就是a的地址。*p：它的了类型是p所指向的类型，它所占用的地址是p所指向的地址。

	int a = 12;
	int b;
	int *p;
	int **ptr;

	p=&a; //&a的结果是一个指针，类型是int *,指向的类型是int
	      //指向的地址是a的地址
	*p = 24; //*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a
	ptr=&p;//&p的结果是个指针，改指针的类型是p的类型加*，
		   //在这里是int**。该指针所指向的类型是p的类型，这里是int *。
		   //该指针所指向的地址就是指针p自己的地址
	*ptr = &b;//*ptr是个指针，&b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以b来给*ptr赋值就是毫无问题的
	**ptr = 34;//*ptr的结果是ptr所指向的东西，在这里是一个指针
			   //对这个指针再做一次*运算，结果就是一个int类型的变量

### 八、指针表达式 ###

&emsp;一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。

&emsp;由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。

&emsp;当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在此例中，*ptr是一个左值，因为*ptr这个指针已经占据了内存，其实*ptr就是指针pa，既然pa已经在内存中有了自己的位置，那么*ptr当然也有了自己的位置。

	int a, b;
	int array[10];
	int *pa;
	pa = &a;//&a适应指针表达式
	int **ptr = &pa; //&pa也是一个指针表达式
	*ptr = &b; //*ptr和&b都是指针表达式
	pa = array;
	pa++;//这也是指针表达式

	char *arr[20];
	char **parr = arr;//如果把arr看作指针的话，arr也是指针表达式
	char *str;
 	str = *parr; //*parr是指针表达式
	str = *(parr+1); //*(parr+1)是指针表达式
	str = *(parr+2); //*(parr+2)是指针表达式

### 九、数组和指针的关系 ###

&emsp;数组的数组名其实可以看作一个指针;

	int array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, value;
	
	value = array[0];//也可写成：value = *array;
	value = array[3];//也可写成：value = *(array+3);
	value = array[4];//也可写成：value = *(array+4);

&emsp;上例中，一般而言数组名array代表数组本身，类型是int[10]，但如果把array看作指针的话，它指向数组的第0个单元，类型是int*，所指向的类型是数组单元的类型即int。因此*array等于0就一点也不奇怪了。同理，array+3是一个指向数组第3个单元的指针，所以*（array+3）等于3，其他一次类推。

	char *str[3] = {"Hello, this is a sample!", "Hi, good moring.", "Hello World"};
	char s[80];
	strcpy(s, str[0]);//也可写成strcpy(s, *str);
	strcpy(s, str[1]);//也可写成strcpy(s, *(str+1));
	strcpy(s, str[2]);//也可写成strcpy(s, *(str+2));

&emsp;上例中，str是一个三单元的数组，该数组的每一个单元都是一个指针，这些指针个指向一个字符串。把指针数组名str当做一个指针的话，它指向数组的第0号单元，它的类型是char **，它指向的类型是char*。

&emsp;*str也是一个指针，它的类型是char*，它指向的类型是char，它指向的地址是字符串“Hello，this is a sample！”的第一个字符的地址，即’H’的地址。str+1也是一个指针，它指向数组的第一号单元，它的类型是char**，它指向的类型是char*。

&emsp;*（str+1）也是一个指针，他的类型是char*，他所指向的类型是char，他指向“Hi,good morning.”的第一个字符’H’。

&emsp;下面总结一下数组的数组名的问题。声明了一个数组TYPE array[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE [n]；第二，它是一个指针，该指针的类型是TYPE*，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。 

&emsp;在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。  在表达式*array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof(*array)测出的是数组单元的大小。  表达式array+n（其中n=0，1，2，....。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是TYPE*，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。 

	int array[10];
	int (*ptr)[10];
	ptr = &array;

&emsp;上例中ptr是一个指针，它的类型是int(*)[10]，他指向的类型是int[10]，我们用整个数组的首地址来初始化它。在语句ptr=&array中，array代表数组本身。

&emsp;在32位程序中，有：

	sizeof（int（*）[10]）==4
	sizeof（int[10]）==40
	sizeof（ptr）==4


- 指针数组和数组指针的内存布局

指针数组：“存储指针的数组”。是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。

数组指针：“指向数组的指针”。是一个指针，指向一个该数组。因此数组指针也成为“行指针”，它的跨度是一行一行的。

	//航指针====》数组指针
	int main()
	{
		int v[2][3] = { {1,2,3}, {4,5,6} }；
		int (*a)[3] = v;//指向第0行的指针
		cout << **a << endl;
		cout << **(a+1) << endl;//a+1变成指向第1行的指针
	}

![](https://i.imgur.com/y6AXvuu.png)


它的主要用途在二维数组的传递：

	//二维数组的传递
	void test(int (*v)[3])
	{
		cout << v[1][1] << endl
	}
	int main()
	{
		int v[2][3] = { {1,2,3}, {4,5,6} }；
		test(v);
		return 0;
	};

![](https://i.imgur.com/HW2LQPK.png)

### 十、指针和结构类型的关系 ###

	struct MyStruct
	{
		int a;
		int b;
		int c;
	};
	int main()
	{
		MyStruct ss = {20,30,40};//声明了结构对象ss，并把ss的三个成员初始化为20,30和40
		MyStruct *ptr = &ss;//声明了一个指向对象ss的指针。它的类型是MyStruct*，它指向的类型是MyStruct。
		int *pstr = (int *)&ss;//声明了一个结构对象ss的指针。但是它的类型和它的指向的类型和ptr是不同的
	}

通过指针ptr来访问ss的三个成员变量：

	ptr->a;
	ptr->b;
	ptr->c;

通过指针pstr来访问ss的三个成员变量：

	*ptsr;//访问了ss的成员a
	*(ptsr+1);//访问了ss的成员b
	*(ptsr+2);//访问了ss的成员c

但以这种方式去访问ss的三个成员变量并不正规。由于字节对齐的原因，这样访问不能保证一定能访问到对的 你想要的成员变量。


### 十一、指针和函数的关系（函数指针） ###

&emsp;可以把一个指针声明成为一个指向函数的指针。






#### 函数指针作为函数参数 ####

&emsp;只需要在函数的参数列代表中，声明一个函数指针类型的参数即可，然后在调用的时候传给它一个实参就可以了。你可以这么想想，就是把函数指针的赋值语句的等号换成了形参和实参结合的模式就行。


#### 使用函数指针作为返回值 ####

&emsp;函数指针可以作为返回值。首先要保证的一点就是返回的函数指针的类型必须是能够明显的表达在这个函数的声明或定义形式中的，也就是说在这个形式中，要能够包含函数指针所对应的能够确定函数类型的信息：这个函数类型的返回值类型，这个函数类型的参数个数，这个函数类型的参数类型。




#### 使用函数指针数组 ####


使用typedef




24.class
--------

	class A
	{
		int a=0;
	};

&emsp;不能在类中声明变量时直接给变量赋值（编译报错）。应该在构造函数中赋值。

25.C++多继承 虚基类 单继承中构造函数 析构函数的执行
------------------------------

### 一、单继承 ###

核心：在构造子类之前一定要执行父类的一个构造函数。

1.构造函数（不包括复制构造函数）

&emsp;&emsp;顺序：①直接父类；②自己

2.析构函数

&emsp;&emsp;与构造函数 顺序相反

### 二、多继承 ###

和单继承的差别就是：需要考虑到多个直接父类。其他的都相同

1.构造函数（不包括复制构造函数）

&emsp;&emsp;顺序：①所有直接父类（按照基类继承列表中声明的顺序）；②自己

2.析构函数
&emsp;&emsp;与构造函数 顺序相反

### 三、虚基类（为了防止多继承时出现重复超类） ###

&emsp;和多继承的差别就是：要考虑到虚基类，其他的都相同。（虚基类的初始化要早于非虚基类，并且只能由子类对其进行初始化）

1.构造函数（不包括复制构造函数）
&emsp;&emsp;顺序：①所有虚基类（按照基类继承列表中声明的顺序进行查找）；②所有直接父类（按照基类继承列表中声明的顺序）；③自己

2.析构函数
&emsp;&emsp;与构造函数 顺序相反

26.为什么C++中设置虚基类
---------------

&emsp;当在多条继承路径上有一个公共的基类，在这些路径中的某几条汇合处，这个公共的基类就会产生多个实例（或多个副本），若指向保存这个基类的一个实例，可以将这个公共基类说明为虚基类。

&emsp;在继承中产生歧义的原因有可能是继承类继承了基类多次，从而产生了多个拷贝，即布置一次的通过多个路径继承在内存中创建了基类成员的多份拷贝。虚基类的基本原则是在内存中只有基类成员的一份拷贝。这样，通过把基类继承声明为虚拟的，就只能继承基类的一份拷贝，从而消除歧义。用virtual限定符把基类继承说明为虚拟的。

27.多继承产生的二义性问题怎么解决
------------------

多继承产生二义性问题有三种解决方式：

①使用域运算符“::”显式指明所属类

②使用同名覆盖即在子类中再次声明该变量或者方法用以覆盖父类中同名属性或方法

③使用虚基类

28.C++为何设置友元
------------

&emsp;我们一直到类具有封装和信息隐藏的特性。只有类的成员函数才能访问类的私有成员，程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员，但是如果将数据成员都定义为公有的，这又破坏了隐藏的特性。另外，应该看到在某些情况下，特别是在对某些成员多次调用时，由于参数传递，类型检查和安全性检查等都需要时间开销，而影响程序的运行效率。

&emsp;为了解决上述问题，提出一种使用友元的方案。友元是一种定义在类外部的普通函数或类，但它需要在类体内进行说明，为了与该类的成员函数加以区别，在杂货名时加以关键字friend。友元不是成员函数，到那时它可以访问类中的私有成员。友元的作用在于提高程序的运行效率。但是，它又破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。不过，类的访问权限确实在某些应用场合显得有些呆板，从而容忍了友元这一特别语法现象。

&emsp;友元关系不具有对称性。即A是B的友元，但B不一定是A的友元。友元关系不具有传递性，即B是A的友元，C是B的友元，但是C不一定是A的友元。

29.什么是多态
--------


30.C++对象内存布局
------------

### 一、空类 ###


输出：1byte。这个1byte是额外分配的。如果不分配空间，这个对象就没有内存地址了，而对象时必须占空间的。

### 二、继承类 ###

                    

可以看出继承后的子类对象在存放的时候是先把父类当成一个整体存放，然后在存放自身变量。

### 三、带虚函数继承 ###

#### 1.单继承带虚函数（有虚函数就会有虚函数指针） ####

#### 2.多继承虚函数 ####

    class A
    {
    public:
    	virtual void f1() {};
    };
    class B
    {
    public:
    	virtual void f2() {};
    };
    class C :public A, public B
    {
    public:
    	virtual void f3() {};
    };
    int main()
    {
    	A a;
    	B b;
    	C c;
    	cout << sizeof(a) << endl;
    	cout << sizeof(b) << endl;
    	cout << sizeof(c) << endl;
    	return 0;
    }

![](https://i.imgur.com/klHJVoy.png)

&emsp;一个父类对应一个虚函数指针，子类重写了父类的虚函数就更新对应父类虚函数列表（如果布置一个父类中有该虚函数，则这些父类的虚函数列表都要更新）。如果子类定义了新的虚函数，则更新第一个父类对应的虚函数列表（子类的虚函数列表跟第一个父类虚函数列表是合并在一起的）。

#### 3.RTTI（面试宝典——11.7面试题例一） ####

    #include<iostream>
    using namespace std;
    
    class base
    {
    public:
    	virtual void funA() { cout << "base" << endl; };
    };
    class derived:public base
    {
    public:
    	virtual void funB() { cout << "derived" << endl; };
    };
    void funC(base *p)
    {
    	derived *dp = dynamic_cast<derived*(p);
    	if (dp != NULL)
    		dp->funB();
    	else
    		p->funA();
    }
    void funD(base *p)
    {
    	derived *dp = NULL;
    	if (typeid(*p) == typeid(derived))
    	{
    		dp = static_cast<derived*>(p);
    		dp->funB();
    	}
    	else
    		p->funA();
    }
    int main()
    {
    	base *cp = new derived;
    	cout << typeid(cp).name() << endl;
    	cout << typeid(*cp).name() << endl;
    	funD(cp);
    	funC(cp);
    	base *dp = new base;
    	funC(dp);
    	funD(dp);
    	return 0;
    }
用于返回一个变量或数据类型的“类型”。


&emsp;假设有一类A，具有虚函数，类B，C，D均从类A中继承而来，且都对类A的虚函数进行了重写。


&emsp;&emsp;（1）这时有类A的指针p，再把对象类B的对象的地址赋值给指针p，则typeid(p).name()将返回的类型是A*。因为这里的p表示的是一个指针，该指针是类型为A的指针，所以返回A*，而typeid(*p).name()将返回B，因为指针p是指向类B 的对象的，而*p就是类B对象的类型，所以返回B。


&emsp;&emsp;（2）这时类A的指针p和p1，按照虚函数的原理，基类指针可以指向任意派生类的对象，在这时可能就需要比较两个指针是否指向同一个对象。typeid(*p)==typeid(*p1)。


&emsp;这里要注意的是：typeid(*p)和typeid(*p1)指向的是指的不同的对象类型，typeid(p)表示的是p的类型，在这里p是一个指针，这个指针指向的是类A的对象，所以p的类型是A*，而typeid(*p)则不一样，*p表示的是指针p实际所指的对象的类型。比如这里的指针p指向派生类B， 则typeid(*p)的类型是B。如果typeid(p)==typeid(p1)的话，则无论指针p和p1指向的是什么派生类对象，他们都是相等的，都是A*的类型。

![](https://i.imgur.com/JjyaIKd.png)
   
### 四、虚基类对象内存模型 ###

	//虚基类对象内存模型
	class MyClass
	{
		int var;
	public:
		void fun(){};
	};
	class MyClassA：virtual public MyClass
	{
		int varA;
	public:
		void fun(){};
		virtual void funA(){};
	};
	class MyClassB:virtual public MyClass
	{
		int varB;
	public:
		void fun(){};
		virtual void funB(){};
	};
	class MyClassC:public MyClassA, public MyClassB
	{
		int varC;
	public:
		virtual void funB(){};
		virtual void funC(){};
	};
	int main()
	{
		MyClassC c;
		cout << "MyClassC 占用内存：" << sizeof(c) << endl;
		return 0;
	}

&emsp;虚基类的作用：如果一个派生类有多个直接基类，而这些直接基类又有一个共同的基类，则在最终的派生类中会保留该间接共同基类数据成员的多份同名成员。

&emsp;在继承时指定MyClass类为虚基类。因为MyClassA与MyClassB有共同的基类，而MyClassC又从MyClassA与MyClassB中继承，为了使MyClassC中只保留间接共同基类的一份成员，采用了虚基类的办法——virtual关键字。

注意：

1.虚基类并不是在声明基类时声明的，而是在声明派生类时，指定继承方式时声明的。

2.为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类。否则仍然会出现对基类的多次继承。

&emsp;虚基类的初始化入股则在粗积累中定义了带参数的构造函数，而且没有定义默认构造函数，，则在其所有派生类（包括直接派生或间接派生的派生类）中，通过构造函数的初始化表对虚基类进行初始化。

&emsp;在最后的派生类中不仅要负责对其直接基类进行初始化，还药负责对虚基类初始化。C++编译系统只执行最后的派生类对虚基类的构造函数的调用，而忽略虚基类的其他派生类（如MyClassA和MyClassB）。

![](https://i.imgur.com/ATdr9UD.png)

	MyClass：（int var）4
	MyClassA：（int varA）4+（virtual void funA）4+（virtual public MyClass）4+（int var）4=16
	MyClassB：（int varB）4+（virtual void funB）4+（virtual public MyClass）4+（int var）4=16
	MyClassC：（int varC）4+sizeof（MyClassA）=16+sizeof（MyClassB）=16-（int var）4=32

31.C++类型强制转换
------------

&emsp;在C++语言中新增了四个关键字static_cast、const_cast、reinterpret_cat和dynamic_cast。这四个关键字都是用于强制类型转换的。

### （1）static_cast<类型说明符> （变量或表达式） ###

&emsp;&emsp;用于数据类型的强制转化。

用法：

a.用于类层次结构找那个基类和派生类之间指针或引用的转换

进行上行转换（把派生类的指针或引用转换成基类表示）是安全的。

进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的。

b.用于基本数据类型之间的转换，如把int转换成char。这种住哪换的安全也要开发人员来保证。

c.把空指针转换成目标类型的空指针

d.把任何类型的表达式转换为void类型

### （2）const_cast<type_id>(expression) ###

&emsp;const_cast用于强制去掉不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。

const_cast关键字的使用：

例1：
       
	#include<iostream>
	using namespace std;
	int main01()
	{
		const int a = 10;
		const int *p = &a;
		int *q;
		q = const_cast<int *>(p);
		*q = 20;
		cout << a << " " << *p << " " << *q << endl;
		cout << &a << " " << p << " " << q <<endl;
		return 0;
	}


![](https://i.imgur.com/InTAF2G.png)
    
将p指针通过const_cast去掉其常量性，并赋给q指针。

例2 ：

	#include<iostream>
	using namespace std;
	const int *Search(const int *a, int n, int val);
	
	int main
	{
		int a[10] = {0,1,2,3,4,5,6,7,8,9};
		int val = 5;
		int *p;
		p = const_cast<int *>(Search(a, 10, val));
		if(p==NULL)
			cout << "Not found the val in array a" << endl;
		else
			cout << "have found the val in array a and the val = " << p << endl;
		return 0:
	}

	const int *Search(const int *a, int n, int val)
	{
		int i;
		for( i = 0; i < n; i++)
		{
			if( a[i] == val)
				return a[i];
		}
		return NULL;
	}

![](https://i.imgur.com/RPKi0R0.png)

&emsp;以上函数用于在a数组中寻找val值，如果找到了就返回改值的地址，如果没有找到就返回NULL。函数Search返回值是const指针，当我们在a数组中找到了val值时，我们会返回val的地址，最关键的是数组a在main函数中并不是const，因此即使我们去掉返回值的常量性有可能会造成数组a被修改，但是这也是安全的。

例3：

	const int &Search2(const int *a, int n, int val);
	
	int main
	{
		int a[10] = {0,1,2,3,4,5,6,7,8,9};
		int val = 5;
		int &p = const_cast<int &>(Search2(a, 10, val));
		if(p==NULL)
			cout << "Not found the val in array a" << endl;
		else
			cout << "have found the val in array a and the val = " << p << endl;
		return 0:
	}

	const int &Search2(const int *a, int n, int val)
	{
		int i;
		for( i = 0; i < n; i++)
		{
			if( a[i] == val)
				return a[i];
		}
		return NULL;
	}

![](https://i.imgur.com/VIX9wn7.png)

&emsp;以上是对于引用，使用const_cast来强制去掉常量性。

### （3）reinterpret_cast<type_id>(expression) ###

&emsp;在C++语言中，reinterpret_cast主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转换为指针或引用类型。

&emsp;type_id必须是一个指针、引用、算数类型、函数指针或者成员指针。

&emsp;它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。

### （4）dynamic_cast<type_id>(expression) ###

1）其它三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要类型检查；

2）不能用于内置的基本数据类型的强制转换；

3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则返回NULL；

4）使用dynamic_cast进行转换的，基类一定要有虚函数，否则编译不通过。

&emsp;B中需要检测虚函数的原因：类中存在虚函数，就说明他有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。

5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的，在进行下行转化时，dynami_cast具有类型检查的功能，比static_cast更安全。

&emsp;向下转换成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。

例1：

	#include<iostream>
	using namespace std;
	class base
	{
	public:
		void m(){cout << "m" << endl;
	};
	class derived:public base
	{
	public:
		void f(){cout << "f" <<endl;}
	};
	int main()
	{
		derived *p;
		//p = new base;
		//p = dynamic_cast<derived *>(new base);
		//被注掉的两处编译不通过：
	（1）定义了一个派生类指针，将其指向基类对象，这是错误的。
	（2）由于直接转化是错误的，我们可以通过强制转换。若使用static_cast<derived *>(new base)；这样会带来一定的危险性。但是我们可以通过dynamic_cast<derived *>(new base)来进行强转。但是在使用dynamic_cast来进行强转时，有一个前提就是要有虚函数以及虚函数重写。所以在这里第二处编译不通过。
		p->m();
		p->f();
		return ;
	}

32.联合体
------

&emsp;“联合”是一种特殊的类，也是一种构造类型的数据结构。在“联合”内，各成员共享一段内存空间，一个联合变量的长度等于各成员中最长的长度。

33.多态相关
-------

### 1.多态性 ###

&emsp;指相同对象收到不同消息或不同该对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性（静态联编），运行时多态性（动态联编）

a、编译时多态性：通过重载函数实现

b、运行时多态性：通过虚函数实现

### 2.虚函数 ###

&emsp;虚函数时在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态覆盖（Override）。

### 3.抽象类 ###

&emsp;包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。

	class A
	{
	public:
		void f1()
		{
			printf("A f1 running!\n");
		}
		virtual void f2()
		{
			printf("A f2 running!\n");
		}
	};
	class B: public A
	{
	public:
		void f1()
		{
			printf("B f1 running!\n");
		}
		virtual void f2()
		{
			printf("B f2 running!\n");
		}
	};
	int main()
	{
		A a;
		B b;
		B *p = (B*)&a;
		p->f1();
		p->f2();
		/*对于B *p=(B *)&a
     	      p->f1();
              P->f2();
	p是一个子类指针。a是一个父类对象，将一个父类对象强制类型转换成子类型后赋值给子类指针。
	  1.这时候调用f1()方法，由于f1()并不是虚函数，而p是一个子类指针，所以p->f1()指向的额是子类的f1()方法。
	  2.而调用f2()时，由于f2()是一个虚函数，所以要去a对象的虚函数列表中查询f2()的入口地址，而这个入口地址是A类中定义的f2()函数，所以输出 A f2 running!
		![](https://i.imgur.com/jufEaAr.png)
		*/


		A*q = &b;
		q->f1();
		q->f2();
		/*对于  B b
    	 	   A *q=&b;
     		   q->f1();
      		   q->f2();
		1. q是一个A类型的指针，f1()为一般成员函数，所以，q->f1()调用的是A类里面定义的f1()方法。
		2. f2()为虚函数，所以调用f2()时会去查找对象b的虚函数列表，b是一个B类对象，这里存放的B类的f2()方法，所以输出B f2() running!。
		![](https://i.imgur.com/1mFNrjK.png)
		*/
		

		return 0;
	}

34.数组名与指针
---------

	void arrayTest(char str[])
	{
		cout << szieof(str) << endl;
	}
	int main()
	{
		char sr1[10] = "I Love U";
		arrayTest(str1);
		return 0;
	}

&emsp;程序输出为4。数组名内涵为数组这种数据结构。这主要是因为：

（1）数组名作为函数形参是，在函数体内，其失去了本身的内涵，仅仅只是一个指针；

（2）在失去内涵的同时，他还失去了其常量特性，可以作自增、自减等操作，可以被修改。

&emsp;所以，数组名作为函数形参时，就变为一个普通的指针。

35.字符串数组
--------

	int main()
	{
		char str1[] = "abcde";
		char str2[] = {'a', 'b', 'c', 'd', 'e'};
		char *p;
		p =&str2[4] + 1;
		*p ='!';
		p = p + 1;
		*p = '\0';
		printf( "str1: %s\n", str1);
		printf( "str2: %s\n", str2);

		return 0;
	}

36.const，define
---------------

&emsp;当你声明变量时，如果变量的值不会被修改，你应当在声明中使用const，这种做法不仅使你的意图在其他人阅读你的程序时能够更加清晰的展现，当这个值被意外修改时，编译器也能及时检测到这种非法的修改。

&emsp;&emsp;define以及typedef也能用于声明名字常量
&emsp;&emsp;#define Max_Elements 50
&emsp;&emsp;int cost Max_Elements=50;  这两者区别不大。



- const修饰数据成员

&emsp;修饰数据变量，保证数据变量只能在定义的时候进行初始化，并且在程序的执行过程中不能被再次赋值。

（1）修饰类中的数据成员变量，可以直接在声明的时候进行初始化（const int num=100；），不过最好还是在构造函数的初始化列表中进行初始化（必须用初始化列表进行初始化）。

	class A
	{
	public:
		A(int val):num(val){}
	private:
		const int num;//const成员变量
	}；

（2）也可以在程序中定义const变量。const int num=100;//比如在定义全局const变量num=100；

（3）const int num=100；等价于 int const num=100;也就是说const int和int const是一个意思。



- const修饰成员函数

（1）const修饰成员函数的返回类型

	class A
	{
	public:
		A(int val):num(val){}
		const void fun(int val)  //<<===>>void const fun(int val)
		{
			cout << "num=" << num << endl;
			age = val;
		}
	private:
		const int num; //const成员变量
		int age;
	};

（2）const修饰成员函数的形参变量

此时const的位置有下面两种等价的情况：

	void fun(const int val);

	void fun(int const val);

（3）const直接修饰成员函数

&emsp;const放在函数声明之后，函数实现之前。void fun（int val）const；const此时保证不会修改该对象的数据成员。

错误案例：

	class A
	{
	public:
		A(int val):num(val){}
		const void fun(int val) const 
		{
			cout << "num=" << num << endl;
			***age*** = val;//age出错
		}
	private:
		const int num; //const成员变量
		int age;
	};

1)const成员函数此时能访问const和非const数据成员。但不能修改非const数据成员。

2)const成员函数中只能调用其它const的成员函数。

3)void fun（int val）const；和void fun（int val）；两个函数构成重载函数。const对象只能调用const成员函数。非const对象会优先调用非const成员函数，但是如果fun函数只有const函数，那么非const对象也会调用const成员函数（但是该非const成员函数中不能修改对象成员变量）。



- const修饰类对象

&emsp;定义一个const对象a：const A a(100);

&emsp;const修饰函数，是从函数的层面，不修改数据。

&emsp;const修饰类对象，是从对象的层面，不修改数据，只能调用const成员函数。

**const对象只能调用const成员函数。**

&emsp;非const对象会优先调用非const成员函数，但是如果fun函数只有const函数，那么非const对象也会调用const成员函数。（但是该非const成员函数中不能修改对象成员变量）



- const修饰指针

	int b=500;
	const int* a=&b;        //情况1 
	int const *a=&b;        //情况2
	int* const a=&b;        //情况3
	const int* const a=&b;    //情况4

1)情况1

&emsp;如果const位于*的左侧，则const就是用来修饰指针所指向的变量。即指针指向为常量；如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。因此1和2的情况相同，都是指针所指向的内容为常量（与const放在变量声明符中的位置无关），这种情况下不允许对内容进行更改操作。

&emsp;换句话说，如果a是一名仓库管理员的话，他所进入的仓库，里面的货物（*a）是他没权限允许动的，仓库里面的东西原来是什么就是什么。所以

	int b=500;
	const int* a=&b;
	*a=600; //错误

&emsp;但是也有别的办法改变*a的值，一个是通过改变b的值：
      
	int b=500;
    const int* a=&b;
    b=600;
    cout<<*a<<endl;  //得到600

&emsp;还有一种办法改变*a就是a指向别处（管理员换个仓库）
      
	int b=500,c=600;
    const int* a=&b;
    a=&c;
    cout<<*a<<endl;  //得到600

2)情况2与情况1相同

3)情况3位指针本身是常量，这种情况下不能对指针本身进行更改操作，而指针所指向的内容不是常量。

&emsp;举例说来：如果a是一名仓库管理员的话，他只能进入指定的仓库，而不能去别的仓库（所以a++是错误的）；但这个仓库里面的货物（*a）是可以随便动的。（*a=600是正确的）。

&emsp;此外，对于情况3：定义时必须同时初始化。
      
	int b=500, c=600;   
    int *const a;      //错误 没有初始化
    int *const a=&b;   //正确 必须初始化
    *a=600;          //正确 允许改值
    cout<<a++<<endl;  //错误

4)对于情况4位指针本身和指针所指向的内容均为常量。那么这仓库管理员只能去特定的仓库，并且仓库里面所有的货物他都没有权限去改变。

37.静态成员函数和静态成员变量
----------------

&emsp;与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，一次它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问静态成员函数，只能调用其他的静态成员函数。

38.extern C
-----------

&emsp;在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况？

&emsp;答：C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern“C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。

39.C语言连接属性
----------

&emsp;当组成一个程序的各个源文件分别被变异之后，所有的目标文件以及那些从一个或多个函数库中引用的函数连接在一个，形成可执行程序。然而，如果相同的标识符出现在几个不同的源文件中时，它们是像Pascal那样表示同一个实体？还是表示不同的实体？标识符的链接属性（linkage）决定如何处理在不同文件中出现的标识符。标识符的作用域与它的链接属性有关，但这两个属性并不同。